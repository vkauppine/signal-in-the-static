<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fi" xml:lang="fi"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vesa">

<title>The Folding Knife – valtapeli ilman lohikäärmeitä – Signal in the Static</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cd884f2855776405ca61470c593c983e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Ei tuloksia",
    "search-matching-documents-text": "tulokset",
    "search-copy-link-title": "Kopioi linkki hakuun",
    "search-hide-matches-text": "Piilota loput tulokset",
    "search-more-match-text": "tulos tässä dokumentissa",
    "search-more-matches-text": "tulosta tässä dokumentissa",
    "search-clear-button-title": "Tyhjennä",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Peruuta",
    "search-submit-button-title": "Lähetä",
    "search-label": "Hae"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Signal in the Static</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Hae"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Vaihda navigointi" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Etusivu</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text">RSS</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Folding Knife – valtapeli ilman lohikäärmeitä</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">kirja</div>
                <div class="quarto-category">fantasia</div>
                <div class="quarto-category">arvostelu</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Tekijä</div>
      <div class="quarto-title-meta-contents">
               <p>Vesa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Julkaistu</div>
      <div class="quarto-title-meta-contents">
        <p class="date">20. helmikuuta 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Fantasiaromaani, jossa ei ole örkkejä, lohikäärmeitä, valittua sankaria eikä profetioita. Sen sijaan on pankkitoimintaa, valuuttakurssimanipulaatiota, sotataktiikkaa ja monimutkaisia perhesuhteita. Jos tämä kuulostaa paremmalta kuin maaginen miekka, K.J. Parkerin <em>The Folding Knife</em> on oikea kirja.</p>
<section id="taustaa" class="level2">
<h2 class="anchored" data-anchor-id="taustaa">Taustaa</h2>
<p>K.J. Parker on pseudonyymi, jonka takaa paljastui myöhemmin Tom Holt – tuottelias brittifantasian kirjoittaja, joka on Parkerina julkaissut toistakymmentä romaania ja lukuisia novelleja. Parker-teokset sijoittuvat löyhästi antiikin Rooman ja Bysantin kaltaisiin maailmoihin, joissa magiaa on vähän tai ei lainkaan, mutta politiikkaa, kauppaa ja käsityötaitoa sitäkin enemmän. <em>The Folding Knife</em> julkaistiin vuonna 2010, ja se on yksi Parkerin tunnetuimmista itsenäisistä romaaneista.</p>
</section>
<section id="juoni" class="level2">
<h2 class="anchored" data-anchor-id="juoni">Juoni</h2>
<p>Bassianus Severus – Basso – on Vesanin tasavallan ensimmäinen kansalainen, eräänlainen vaaleilla valittu diktaattori kaupunkivaltiossa, joka muistuttaa myöhäistä Rooman tasavaltaa sekoitettuna renessanssin Italian kauppamahteihin. Basso on älykäs, viihdyttävä ja pohjimmiltaan pragmaattinen. Hän ymmärtää rahaa, ihmisiä ja valtaa, ja hän käyttää kaikkia kolmea taitavasti. Hän uudistaa pankkijärjestelmän, käy sotia, solmii liittoja ja manipuloi markkinoita – kaikki samalla kepeällä itsevarmuudella.</p>
<p>Mutta Basso kantaa mukanaan myös synkkää historiaa. Romaanin ensimmäisillä sivuilla käy ilmi, että hän on nuorena tappanut sisarensa aviomiehen, ja tämän teon seuraukset kulkevat tarinan läpi kuin halkeama lasilevyssä. Basso on mies, joka hallitsee kaiken paitsi oman elämänsä.</p>
</section>
<section id="hahmot" class="level2">
<h2 class="anchored" data-anchor-id="hahmot">Hahmot</h2>
<p>Parkerin suurin vahvuus on hänen hahmonsa. Basso on harvinaisen hyvä päähenkilö: hän on samanaikaisesti sympaattinen ja kyyninen, lahjakas ja sokeasti itsetuhoinen. Hänen ympärillään olevat hahmot – serkku Bassano, sisar Placidia, sotilaskomentajat ja pankkiirit – ovat kaikki uskottavia ja monisyisiä. Kukaan ei ole pelkästään hyvä tai paha. Kaikilla on omat motiivinsa, ja motiivit ovat ymmärrettäviä.</p>
<p>Suomalaiselle lukijalle tulee väistämättä mieleen Waltari. Siinä miten Parker rakentaa hahmojensa moraalista monimutkaisuutta on jotain samaa kuin Sinuhen, Mikael Karvajalkan tai Turms Kuolemattoman hahmoissa – älykkäitä, itsetietoisia ihmisiä jotka näkevät omat heikkoutensa selvästi mutta eivät silti kykene toimimaan toisin. Basso tietää tekevänsä virheitä. Hän analysoi ne jälkikäteen terävämmin kuin kukaan muu. Ja tekee ne silti uudelleen.</p>
</section>
<section id="talous-ja-politiikka" class="level2">
<h2 class="anchored" data-anchor-id="talous-ja-politiikka">Talous ja politiikka</h2>
<p>Yksi romaanin parhaista puolista on se, miten vakavasti se suhtautuu talouteen. Parker kirjoittaa valuuttakaupoista, lainarakenteista ja valtiontalouden hallinnasta tavalla, joka on sekä uskottava että aidosti juonellisesti kiinnostava. Basson pankkiuudistukset eivät ole pelkkää rekvisiittaa – ne ovat tarinan ytimessä, yhtä jännittäviä kuin sotakohtaukset. Harvassa fantasiaromaanissa korkopolitiikka on juonenkäänne, mutta täällä se toimii.</p>
<p>Samalla Parker ymmärtää, ettei talous ole irrallaan vallasta. Basson taloudelliset päätökset ovat aina myös poliittisia: kuka hyötyy, kuka häviää, kuka jää velkaa ja kenelle. Tasavallan rakenteissa näkyy sekä Rooman senaatti että Firenzen pankkiirit, ja Parker tuntee molemmat riittävän hyvin kirjoittaakseen niistä uskottavasti.</p>
</section>
<section id="kerronta" class="level2">
<h2 class="anchored" data-anchor-id="kerronta">Kerronta</h2>
<p>Tässä on myös romaanin selvin heikkous, tai ainakin piirre joka jakaa lukijoita. Parkerin kerronta on paikoin etäännyttävän tiivistävää. Kohtauksia jotka ansaitsisivat tilan hengittää – sotaretki, neuvottelu, perhekriisi – käsitellään joskus muutamalla kappaleella yhteenvedon omaisesti. Tuntuu ajoittain kuin lukisi erinomaista tiivistelmää vielä paremmasta kirjasta. Parker luottaa lukijan päättelykykyyn, mikä on sinänsä kunnioittavaa, mutta se jättää emotionaalisen etäisyyden jonka kaikki lukijat eivät välttämättä halua. Toisaalta tämä tekee kirjasta varsin nopealukuisen ja 440-sivuisena se tuntuu huomattavasti mittaansa lyhyemmältä.</p>
<p>Tämä on tietoinen tyylivalinta eikä virhe, mutta se tarkoittaa, että romaanin paras hetki ei ole yksittäinen dramaattinen kohtaus vaan kokonaisuuden hahmottuminen: se liike, jossa lukija alkaa nähdä kaiken mihin Basson valinnat johtavat, ja tajuaa ettei Basso itse näe sitä – tai ei halua nähdä.</p>
</section>
<section id="lukukokemuksena" class="level2">
<h2 class="anchored" data-anchor-id="lukukokemuksena">Lukukokemuksena</h2>
<p><em>The Folding Knife</em> on fantasiaromaani ihmisille jotka eivät välttämättä lue fantasiaa. Se ei vaadi maailmanrakennuksen opiskelua eikä edellytä kiinnostusta magiajärjestelmiin. Se vaatii kiinnostusta ihmisiin, valtaan ja siihen miten älykkäät ihmiset tuhoavat itsensä järjestelmällisesti omilla päätöksillään.</p>
<p>Se on myös harvinaisen hyvä kirja suositeltavaksi jollekulle, joka pitää historiallisista romaaneista mutta ei ole koskaan lukenut fantasiaa. Tai toisin päin: fantasian lukijalle joka haluaa jotain ilman taikasodan mekanismeja ja valitun sankarin kohtaloa.</p>
<p>Juonenkäänteitä on riittävästi pitämään kiinnostus yllä. Ja loppu on juuri sellainen kuin sen pitääkin olla. Se ei ole yllättävä, mutta vääjäämätön. Kuten parhaissa tragedioissa, lukija näkee lopun tulevan mutta ei voi estää sitä. Eikä Basso itsekään.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopioitu!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopioitu!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/vkauppine\.github\.io\/signal-in-the-static\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="dark">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "vkauppine/signal-in-the-static";
    script.dataset.repoId = "R_kgDORTnEzQ";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDORTnEzc4C259C";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fi" xml:lang="fi"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vesa">

<title>Flowers for Algernon – kirja, joka ei päästä helpolla – Signal in the Static</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cd884f2855776405ca61470c593c983e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Ei tuloksia",
    "search-matching-documents-text": "tulokset",
    "search-copy-link-title": "Kopioi linkki hakuun",
    "search-hide-matches-text": "Piilota loput tulokset",
    "search-more-match-text": "tulos tässä dokumentissa",
    "search-more-matches-text": "tulosta tässä dokumentissa",
    "search-clear-button-title": "Tyhjennä",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Peruuta",
    "search-submit-button-title": "Lähetä",
    "search-label": "Hae"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Signal in the Static</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Hae"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Vaihda navigointi" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Etusivu</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Flowers for Algernon – kirja, joka ei päästä helpolla</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">kirja</div>
                <div class="quarto-category">tieteiskirjallisuus</div>
                <div class="quarto-category">arvostelu</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Tekijä</div>
      <div class="quarto-title-meta-contents">
               <p>Vesa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Julkaistu</div>
      <div class="quarto-title-meta-contents">
        <p class="date">20. helmikuuta 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Tieteiskirjallisuus ei tarvitse avaruusaluksia. Se ei tarvitse vieraita planeettoja tai dystooppisia hallintokoneistoja. Joskus riittää yksi ihminen, yksi laboratoriohiiri ja kysymys, johon ei ole hyvää vastausta: mitä tapahtuu, jos älykkyyttä voi ostaa leikkauspöydältä – ja mitä tapahtuu, kun lasku tulee perässä?</p>
<section id="taustaa" class="level2">
<h2 class="anchored" data-anchor-id="taustaa">Taustaa</h2>
<p>Daniel Keyes julkaisi <em>Flowers for Algernon</em> -tarinan alun perin novellina vuonna 1959. Se voitti Hugo-palkinnon. Laajennettu romaaniversio ilmestyi 1966 ja sai Nebula-palkinnon. Molempia pidetään ansaittuina. Suomeksi kirja julkaistiin 1985 Hilkka Pekkasen kääntämänä, mutta luin kirjan englanniksi.</p>
<p>Kirja syntyi aikana, jolloin käyttäytymistieteet ja älykkyyden mittaaminen olivat nosteessa. ÄO-testit olivat vakavasti otettava työkalu, kokeellinen psykologia lupasi selittää ihmisen käytöksen, ja lääketiede teki suuria lupauksia. Kylmän sodan teknologinen kilpailu ruokki uskoa siihen, että ihmistäkin voi optimoida. Keyesin romaani ei niinkään vastustanut tätä optimismia kuin kysyi: entä jos se toimii? Entä jos se todella toimii – ja sitten lakkaa toimimasta?</p>
</section>
<section id="juoni" class="level2">
<h2 class="anchored" data-anchor-id="juoni">Juoni</h2>
<p>Charlie Gordon on kehitysvammainen mies, joka työskentelee leipomossa ja haluaa oppia. Hän osallistuu kokeelliseen leikkaukseen, joka on aiemmin tehty laboratoriohiirelle nimeltä Algernon. Leikkaus onnistuu. Charlien älykkyys kasvaa nopeasti, ensin normaalille tasolle, sitten paljon sen yli. Hän ohittaa opettajansa, tutkijansa ja kaikki ympärillään.</p>
<p>Mutta älykkyyden mukana tulee ymmärrys, ja ymmärrys tuo mukanaan asioita, joita Charlie ei osannut odottaa. Hän alkaa nähdä, miten häntä on kohdeltu. Hän ymmärtää, että ihmiset joita hän piti ystävinään nauroivat hänelle, eivät hänen kanssaan. Ja sitten Algernon alkaa taantua.</p>
<p>Enempää juonesta ei ole syytä kertoa.</p>
</section>
<section id="kieli-ja-rakenne" class="level2">
<h2 class="anchored" data-anchor-id="kieli-ja-rakenne">Kieli ja rakenne</h2>
<p>Romaanin muodollinen ratkaisu on sen paras oivallus. Tarina kerrotaan kokonaan Charlien omien “progress reportien” kautta – raporttien, joita hän kirjoittaa tutkijoille osana koetta.</p>
<p>Alussa kieli on juuri sellaista kuin sen pitääkin olla: kömpelöä, täynnä kirjoitusvirheitä, yksinkertaista. Charlie kirjoittaa niin kuin osaa. Sivujen edetessä oikeinkirjoitus korjaantuu, sanasto laajenee, lauserakenteet monimutkaistuvat. Jossain vaiheessa lukija huomaa lukevansa proosaa, joka on analyyttistä, syvällistä ja kaunista. Muutos tapahtuu niin orgaanisesti, ettei sitä välttämättä edes huomaa ennen kuin pysähtyy miettimään.</p>
<p>Ja sitten muutos kääntyy toiseen suuntaan. Hitaasti, mutta vääjäämättömästi. Kielen rapautuminen on rakenteellisesti hiottua työtä: Keyes antaa lukijalle vihjeitä tulevasta ennen kuin juoni paljastaa mitään suoraan. Tekstin muoto kertoo tarinan yhtä paljon kuin sen sisältö.</p>
<p>Tämä ei ole vain kekseliäs temppu. Se on kokonaisvaltainen kerronnallinen ratkaisu, joka sitoo yhteen muodon ja sisällön tavalla, johon harvat romaanit yltävät.</p>
</section>
<section id="teemat" class="level2">
<h2 class="anchored" data-anchor-id="teemat">Teemat</h2>
<p>Romaanin keskeisin kysymys on älykkyys ja ihmisarvo: onko ihminen arvokkaampi, kun hän ymmärtää enemmän? Charlie on yksinäinen sekä ennen leikkausta että sen jälkeen, mutta eri tavoin. Ennen hän ei ymmärrä olevansa yksin. Jälkeen hän ymmärtää sen liiankin hyvin, ja tietää ettei voi palata takaisin tietämättömyyteen.</p>
<p>Keyes ei tarjoa helppoja vastauksia. Kirjan tutkijat eivät ole pahoja ihmisiä – he ovat tieteilijöitä, jotka uskovat tekevänsä oikein. Charlien työkaverit eivät ole tarkoituksellisesti julmia. He ovat vain ajattelemattomia. Ja Charlie itse ei ole pelkkä uhri. Neroksi tultuaan hän kohtelee muita ihmisiä tavalla, joka ei ole sen kauniimpaa kuin se miten häntä kohdeltiin. Hän on ylimielinen, kärsimätön ja kyvytön empatiaan. Näiden samojen puutteiden vuoksi häntä pidettiin vajavaisena ennen leikkausta, mutta nerossa nämä tulevat esiin toisella lailla. Älykkyys ei tee kenestäkään automaattisesti parempaa ihmistä. Se vain antaa uusia tapoja olla huono sellainen.</p>
<p>Taustalla kulkee myös tieteen etiikan kysymys, joka ei ole lainkaan vanhentunut: saako kaiken tehdä, jos se on teknisesti mahdollista? Kenen suostumus riittää, kun koehenkilö ei pysty täysin ymmärtämään mihin suostuu? Ja kenelle vastuu kuuluu, kun kokeilu menee pieleen?</p>
</section>
<section id="lukukokemuksena" class="level2">
<h2 class="anchored" data-anchor-id="lukukokemuksena">Lukukokemuksena</h2>
<p><em>Flowers for Algernon</em> on yllättävän helposti lähestyttävä kirja ottaen huomioon, miten raskaita asioita se käsittelee. Progress report -muoto pitää lukijan otteessaan, koska Charlien ääni on niin välitön. Ei ole kertojaa, joka selittäisi tai pehmentäisi. On vain Charlie ja hänen sanansa. Kirja on myös lyhyt – sen lukee helposti yhdeltä istumalta – mutta se jää pyörimään päähän pitkäksi aikaa.</p>
<p>Kirja saa pohtimaan, mutta se myös saa tuntemaan. Se ei manipuloi, ei vedä tunteisiin halvoilla keinoilla. Se vain kertoo tarinan ja luottaa siihen, että lukija ymmärtää. Ja loppu on todellakin ansaittu, joka tavulla.</p>
<p>Pidän Philip K. Dickin tavasta käsitellä identiteettiä ja ihmisyyttä, mutta Dickillä on aina metafyysistä etäisyyttä, kerros todellisuuden epävarmuutta, joka pitää lukijan askelen päässä hahmosta. Keyes ei anna sitä suojaa. Kaikki on paljaampaa ja henkilökohtaisempaa.</p>
</section>
<section id="merkitys" class="level2">
<h2 class="anchored" data-anchor-id="merkitys">Merkitys</h2>
<p>Kuusikymmentä vuotta julkaisunsa jälkeen <em>Flowers for Algernon</em> kuuluu yhä koulujen lukemistoihin ympäri maailmaa, ja syystä. Mutta se ei ole pelkästään nuortenkirja tai opetusteksti. Se kestää aikuislukijan uudelleenluennan, koska kysymykset joita se esittää eivät vanhene. Älykkyyden, arvon ja ihmisyyden väliset jännitteet ovat edelleen ratkaisematta – ja tekoälykeskustelun aikakaudella, kun pohdimme koneiden älykkyyttä ja sen suhdetta ihmisarvoon, ne tuntuvat ehkä ajankohtaisemmilta kuin koskaan.</p>
<p>Ehdoton klassikko. Yksi niitä harvoja kirjoja, jotka todella ansaitsevat tuon sanan.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopioitu!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopioitu!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/vkauppine\.github\.io\/signal-in-the-static\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>